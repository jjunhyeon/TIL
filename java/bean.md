
### 스프링 빈과 생명주기

## ✔️  배경지식

### 1. Bean

재사용 소프트웨어 컴포넌트, 스프링 컨테이너가 관리하는 자바 객체를 뜻하며. 빈은 인스턴스화된 객체를 의미한다.
빈으로 등록하기 위한 방법으로는 xml에 직접 등록하는 방법과 어노테이션을 이용하는 방법이 있다.

<br>

####  1.xml을 이용해 등록하는 방법

xml을 이용해 등록하는 방법으로는  ```<bean id= "userService" class="com.study.app.userService" />```  처럼 작성해 빈을 등록할 수 있다.

<br>

####  2 어노테이션을 이용하는 방법 

@Component, @Bean

위 어노테이션을 사용한 클래스는 직접 스프링 컨테이너에 빈으로 등록해 사용할 수 있게 해줍니다.

스프링 빈을 어노테이션으로 등록하는 방법은 위 2개의 어노테이션이다.

우리가 일반적으로 흔히 사용하고 있는 @Controller, @Service, @Repository 등의 어노테이션이 빈으로 사용할 수 있는것은 위 @Component 를 상속받아 만들어졌기 때문입니다.
정리하면 빈은 인스턴스화된 객체를 의미하며 스프링 컨테이너에 등록해 사용하는 이유는 재사용과 의존관계 설정을 관리하기 위함이다.

<br>
<br>

### 2. Spring Container 

스프링 컨테이너는 스프링에서 자바 객체들을 관리하는 공간을 말한다.

위에서 언급한 빈(Bean) 을 관리하는 공간을 말하며 스프링 컨테이너에서는 빈의 생성부터 소멸까지를 개발자 대신 관리해준다.

빈을 컨테이너에 등록하는 예제
```
@Configuration
public class SpringConfig {
   @Bean
   public UserService userService() {
       return new UserService();
   }
}
```

@Configuration 애노테이션은 스프링 설정 클래스임을 명시한다. 스프링은 이 클래스를 사용해 애플리케이션 컨텍스트를 구성해 @Bean 어노테이션과 함께 사용되어, 빈을 생성하고 관리하는 역할을 한다.

 
위 소스는 스프링 설정 클래스인 SpringConfig 클래스에 UserService 객체를 스프링 컨테이너에 등록해주는 코드

<br>
<br>
 

### ✔️  빈  생명주기

빈의 생명주기란 빈이 생성되고, 사용되다가 결국 소멸되기까지의 일련의 과정을 말한다.

아래는 빈의 생성부터 소멸까지의 과정이다.

 <br>

`빈 생성   -> 의존관계 주입(DI) -> 빈 초기화 -> 준비 완료 -> 빈의 사용 -> 소멸`

 <br>

### 1. 빈 생성

스프링 컨테이너는 애플리케이션 실행 버튼을 누르는 시점에 로딩된다.

@ComponetScan 을 통해 스캔된 클래스와 @Bean 메서드를 통해 스캔된 클래스를 인스턴스화하여 빈을 생성한다.

  <br>

### 2. 의존성 주입

컨테이너는 빈을 생성하면서 , 해당 빈이 필요로 하는 의존성이 있는지 확인하고 주입한다.

이 의존성은 생성자, 필드, 또는 세터 메서드를 통해 정의될 수 있다.

  <br>

### 3. 빈 초기화

빈의 의존관계가 준비된 이후, 필요한 추가 설정이나 작업을 수행할 수 있도록 제공하는 단계

이 단계가 있는 이유는 설정 작업, 에러 방지, 상태 초기화를 하기 위함입니다. 이를 위해 제공하는 방법으로는 @PostConstruct, InitializingBean, init-method는 빈이 의존성 주입 이후 추가적인 초기화 작업을 수행할 때 사용한다.

  <br>

### 4. 사용 준비 완료

모든 의존성이 빈에게  주입되고 초기화 단계도 지났다면 애플리케이션의 일부로 사용될 준비가 끝난다.  

  <br>

### 5. 애플리케이션 구동

애플리케이션 내에서 빈이 사용된다. 빈은 애플리케이션의 다른 부분에서 주입받아 사용되거나, 직접 호출되어 로직을 수행한다.

  <br>

### 6. 빈의 소멸

애플리케이션이 종료될때, 빈이 소멸된다.

  <br>

## ✔️  빈  주입 방식
의존성 주입 단계에서 빈이 주입되는 방식은  생성자 주입, 필드 주입, 세터 주입이 있으며 각 방식의 차이는 다음과 같다.

 <br>

### 1. 생성자 주입

- 생성자 주입은 빈이 생성될 때 생성자를 통해 의존성을 주입하는 방식입니다. 생성자 파라미터로 의존성이 주입된다.

```
@Component
public class MyService {
    private final MyDependency myDependency;

    @Autowired
    public MyService(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}
```

생성자 주입 방식을 통해 얻는 이점은 아래와 같습니다.

1.불변성: 의존성이 final로 선언될 수 있어 불변성을 유지할 수 있습니다. 객체가 생성될 때 모든 의존성이 주입되므로, 빈이 완전히 초기화된 상태로 사용된다.

2.필수 의존성 명확화: 생성자를 통해 의존성을 주입하므로, 빈이 생성되는 시점에 필요한 모든 의존성이 명확히 요구된다.

3.테스트 용이성: 생성자 주입을 통해 빈을 테스트할 때 의존성을 명확히 주입할 수 있어 단위 테스트가 용이하다.
 

 <br> 

### 2. 필드 주입

필드 주입은 빈의 필드에 직접 의존성을 주입하는 방식이다. @Autowired 를  필드에 붙여 사용한다.

```
@Component
public class MyService {
    @Autowired
    private MyDependency myDependency;
}
```
 

장점 :

간결한 코드: 생성자나 세터 메서드를 작성할 필요 없이 필드에 직접 주입할 수 있어 코드가 간결해집니다.

단점 :

불변성 부족: 필드가 final로 선언될 수 없어, 의존성 주입 후 필드 값이 변경될 수 있습니다.
테스트 용이성: 생성자 주입을 통해 빈을 테스트할 때 의존성을 명확히 주입할 수 있어 단위 테스트가 용이하다.
 
 <br>
 
### 3. 세터 주입

세터 주입은 세터 메서드를 통해 의존성을 주입하는 방식이다. @Autowired 어노테이션을 붙여 사용한다.

```
@Component
public class MyService {
    private MyDependency myDependency;

    @Autowired
    public void setMyDependency(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}
```


장점:

선택적 의존성: 의존성이 선택적일 수 있어, 생성자 주입보다 유연하게 사용할 수 있다.

가독성: 필드 주입보다 생성자 주입에 가까운 방식으로, 세터 메서드를 통해 명확하게 의존성을 주입한다.

단점:

불변성 부족: 의존성이 final로 선언될 수 없어, 주입 후에 의존성 값이 변경될 수 있다.
초기화 시점 문제: 세터 메서드 호출이 빈의 초기화 단계 후에 이루어지므로, 빈이 완전히 초기화되기 전에 의존성에 접근하는 문제가 발생할 수 있다.
 

