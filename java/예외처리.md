
***시작하며***

📌 *[2 - 예외] CheckExcetion과 UncheckedException의 차이에 대해 말할 수 있는것을 목표로 합니다.*

<br>

✔️ *Checked Exception*
Java의 모든 예외는 Throwable을 상속받으며, 그 중 Exception 계열이 Checked / UnChecked Exception으로 나뉜다.

RuntimeException을 상속받는 예외는 UnChecked Exception이며, 그 외 Exception을 상속받은 예외는 Checked Exception이다.


``` java
public class FileService {

    public String readFile(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        return br.readLine();
    }
}
```
경로에 존재하는 파일을 읽는 서비스이다. BufferedReader 에서는 예외처리를 강제하고 있고 위와 같이 예외를 던졌다.


``` java

public class FileController {

    public void read() {
        FileService fileService = new FileService();
        try {
            fileService.readFile("test.txt");
        } catch (IOException e) {
            // 반드시 처리해야 함
            System.out.println("파일을 읽을 수 없습니다.");
        }
    }
}
```
서비스로부터 전가받은 컨트롤러는 반드시 try - catch를 써 위 에외를 처리해줘야한다. 위와 같은 에러는 Checked Exception이기 때문이다.
위 처럼 컴파일을 위해 **예외처리를 강제**하고 있다.

<br>

***Checked Exception의 장/단점***

* Checked Exception은 필요한 예외처리를 미리 알려주고 처리할 수 있기 때문에 관리가 편하다.
* 하지만 예외를 즉시 처리하지 않고 상위 계층으로 전가할 경우, 모든 호출부가 해당 예외를 인지하고 처리해야 한다. 이로 인해 계층 간 결합도가 높아지고 코드가 지저분해진다.


<br>

✔️ *Unchecked Exception*
위 예외를 제외한 모든 에러, 두번쨰 RuntimeException을 상속받는 Unchecked Exception에 대한 내용이다.
``` java
public class MemberService {

    public void updateAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
        }
    }
}
```
예외를 그 자리에서 바로 IllegalArgumentException 로 처리한 코드이다.

``` java
public class MemberController {

    public void update() {
        MemberService service = new MemberService();
        service.updateAge(-1);
    }
}
```
컨트롤러에선 해당 예외가 RuntimeException이기 때문에 try - catch를 강제하지 않는다. 예외는 서비스 계층에서 발생했지만, 호출 스택을 따라 상위로 전파된다.


<br>

***Unchecked Exception의 장/단점***

* Unchecked Exception은 복구가 불가능하거나 비즈니스적으로 즉시 중단되어야 하는 상황에 처리해야하며, 컴파일 단계에서 예외 처리를 강제하지 않기 때문에 불필요한 try-catch가 줄어들고, 예외 전파 구조를 단순하게 유지할 수 있다.


<br>

### 정리하며

Checed Exception과 Unchecked Exception의 차이는 예외를 어디서 책임질 것인가에 대한 설계의 문제이다.

복구가 가능한 예외라면 Checked Exception이 적잡하지만, 실무에서는 대부분 예외가 복구 불가능하거나 비즈니스적으로 즉시 중단되어야 하는 경우가 많다. 이 때문에 많은 프레임워크와 서비스 설계시에도 Unchecked Exception을 중심으로 예외를 구성하고, 공통 예외 처리를 통한 일관된 대응 전략으로 설계 및 처리하는 습관이 필요하다.


